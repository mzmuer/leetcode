## 题目：[车的可用捕获量](https://leetcode-cn.com/problems/available-captures-for-rook/)

在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。

**示例1:**
>输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]  
>输出：3  
>解释：  
>在本例中，车能够捕获所有的卒。

**示例2:**
>输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]  
>输出：0  
>解释：  
>象阻止了车捕获任何卒。

**示例3:**
>输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]  
>输出：3  
>解释：   
>车可以捕获位置 b5，d6 和 f5 的卒。

提示：
* `board.length == board[i].length == 8`
* `board[i][j]` 可以是 `'R'`，`'.'`，`'B'` 或 `'p'`
* 只有一个格子上存在 `board[i][j] == 'R'`

## 思路
1. 模拟题，按照题目描述做就好
2. 首先定义一个方向数组，遍历四个方向累计得到结果。

## [实现](https://github.com/mzmuer/leetcode/blob/master/question999/answer_test.go)
```go
func numRookCaptures(board [][]byte) int {
	var ans int
	dt := [4][2]int{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}

	for row := 0; row < 8; row++ {
		for col := 0; col < 8; col++ {
			if board[row][col] == 'R' {
				for _, d := range dt {
					ans += _impel(board, row, col, d)
				}
				break
			}
		}
	}

	return ans
}

func _impel(board [][]byte, x, y int, d [2]int) int {
	for {
		x += d[0]
		y += d[1]
		if x < 0 || x >= 8 || y < 0 || y >= 8 {
			break
		}

		if board[x][y] == 'B' {
			return 0
		} else if board[x][y] == 'p' {
			return 1
		}
	}

	return 0
}
```